import{W as h,a as p,c as d,w as f}from"./workbox-core-C1cRqoWm.js";import{R,r as w}from"./workbox-routing-BdHYqEkA.js";import{S as C}from"./workbox-strategies-CzbM8t1Y.js";try{self["workbox:precaching:7.2.0"]&&_()}catch{}const m="__WB_REVISION__";function U(c){if(!c)throw new h("add-to-cache-list-unexpected-type",{entry:c});if(typeof c=="string"){const i=new URL(c,location.href);return{cacheKey:i.href,url:i.href}}const{revision:e,url:t}=c;if(!t)throw new h("add-to-cache-list-unexpected-type",{entry:c});if(!e){const i=new URL(t,location.href);return{cacheKey:i.href,url:i.href}}const s=new URL(t,location.href),a=new URL(t,location.href);return s.searchParams.set(m,e),{cacheKey:s.href,url:a.href}}class K{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:e,state:t})=>{t&&(t.originalRequest=e)},this.cachedResponseWillBeUsed=async({event:e,state:t,cachedResponse:s})=>{if(e.type==="install"&&t&&t.originalRequest&&t.originalRequest instanceof Request){const a=t.originalRequest.url;s?this.notUpdatedURLs.push(a):this.updatedURLs.push(a)}return s}}}class L{constructor({precacheController:e}){this.cacheKeyWillBeUsed=async({request:t,params:s})=>{const a=(s==null?void 0:s.cacheKey)||this._precacheController.getCacheKeyForURL(t.url);return a?new Request(a,{headers:t.headers}):t},this._precacheController=e}}class o extends C{constructor(e={}){e.cacheName=d.getPrecacheName(e.cacheName),super(e),this._fallbackToNetwork=e.fallbackToNetwork!==!1,this.plugins.push(o.copyRedirectedCacheableResponsesPlugin)}async _handle(e,t){const s=await t.cacheMatch(e);return s||(t.event&&t.event.type==="install"?await this._handleInstall(e,t):await this._handleFetch(e,t))}async _handleFetch(e,t){let s;const a=t.params||{};if(this._fallbackToNetwork){const i=a.integrity,n=e.integrity,r=!n||n===i;s=await t.fetch(new Request(e,{integrity:e.mode!=="no-cors"?n||i:void 0})),i&&r&&e.mode!=="no-cors"&&(this._useDefaultCacheabilityPluginIfNeeded(),await t.cachePut(e,s.clone()))}else throw new h("missing-precache-entry",{cacheName:this.cacheName,url:e.url});return s}async _handleInstall(e,t){this._useDefaultCacheabilityPluginIfNeeded();const s=await t.fetch(e);if(!await t.cachePut(e,s.clone()))throw new h("bad-precaching-response",{url:e.url,status:s.status});return s}_useDefaultCacheabilityPluginIfNeeded(){let e=null,t=0;for(const[s,a]of this.plugins.entries())a!==o.copyRedirectedCacheableResponsesPlugin&&(a===o.defaultPrecacheCacheabilityPlugin&&(e=s),a.cacheWillUpdate&&t++);t===0?this.plugins.push(o.defaultPrecacheCacheabilityPlugin):t>1&&e!==null&&this.plugins.splice(e,1)}}o.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate({response:c}){return!c||c.status>=400?null:c}};o.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate({response:c}){return c.redirected?await p(c):c}};class T{constructor({cacheName:e,plugins:t=[],fallbackToNetwork:s=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new o({cacheName:d.getPrecacheName(e),plugins:[...t,new L({precacheController:this})],fallbackToNetwork:s}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(e){this.addToCacheList(e),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(e){const t=[];for(const s of e){typeof s=="string"?t.push(s):s&&s.revision===void 0&&t.push(s.url);const{cacheKey:a,url:i}=U(s),n=typeof s!="string"&&s.revision?"reload":"default";if(this._urlsToCacheKeys.has(i)&&this._urlsToCacheKeys.get(i)!==a)throw new h("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(i),secondEntry:a});if(typeof s!="string"&&s.integrity){if(this._cacheKeysToIntegrities.has(a)&&this._cacheKeysToIntegrities.get(a)!==s.integrity)throw new h("add-to-cache-list-conflicting-integrities",{url:i});this._cacheKeysToIntegrities.set(a,s.integrity)}if(this._urlsToCacheKeys.set(i,a),this._urlsToCacheModes.set(i,n),t.length>0){const r=`Workbox is precaching URLs without revision info: ${t.join(", ")}
This is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(r)}}}install(e){return f(e,async()=>{const t=new K;this.strategy.plugins.push(t);for(const[i,n]of this._urlsToCacheKeys){const r=this._cacheKeysToIntegrities.get(n),l=this._urlsToCacheModes.get(i),g=new Request(i,{integrity:r,cache:l,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:n},request:g,event:e}))}const{updatedURLs:s,notUpdatedURLs:a}=t;return{updatedURLs:s,notUpdatedURLs:a}})}activate(e){return f(e,async()=>{const t=await self.caches.open(this.strategy.cacheName),s=await t.keys(),a=new Set(this._urlsToCacheKeys.values()),i=[];for(const n of s)a.has(n.url)||(await t.delete(n),i.push(n.url));return{deletedURLs:i}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const t=new URL(e,location.href);return this._urlsToCacheKeys.get(t.href)}getIntegrityForCacheKey(e){return this._cacheKeysToIntegrities.get(e)}async matchPrecache(e){const t=e instanceof Request?e.url:e,s=this.getCacheKeyForURL(t);if(s)return(await self.caches.open(this.strategy.cacheName)).match(s)}createHandlerBoundToURL(e){const t=this.getCacheKeyForURL(e);if(!t)throw new h("non-precached-url",{url:e});return s=>(s.request=new Request(e),s.params=Object.assign({cacheKey:t},s.params),this.strategy.handle(s))}}let u;const y=()=>(u||(u=new T),u);function P(c,e=[]){for(const t of[...c.searchParams.keys()])e.some(s=>s.test(t))&&c.searchParams.delete(t);return c}function*b(c,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:t="index.html",cleanURLs:s=!0,urlManipulation:a}={}){const i=new URL(c,location.href);i.hash="",yield i.href;const n=P(i,e);if(yield n.href,t&&n.pathname.endsWith("/")){const r=new URL(n.href);r.pathname+=t,yield r.href}if(s){const r=new URL(n.href);r.pathname+=".html",yield r.href}if(a){const r=a({url:i});for(const l of r)yield l.href}}class I extends R{constructor(e,t){const s=({request:a})=>{const i=e.getURLsToCacheKeys();for(const n of b(a.url,t)){const r=i.get(n);if(r){const l=e.getIntegrityForCacheKey(r);return{cacheKey:r,integrity:l}}}};super(s,e.strategy)}}function v(c){const e=y(),t=new I(e,c);w(t)}function N(c){y().precache(c)}function x(c,e){N(c),v(e)}export{x as p};
