import{d as m,r as u,c as p,W as l}from"./workbox-core-C1cRqoWm.js";import{d as x,o as g}from"./idb-Bn1DMRyg.js";try{self["workbox:expiration:7.2.0"]&&_()}catch{}const w="workbox-expiration",o="cache-entries",d=r=>{const e=new URL(r,location.href);return e.hash="",e.href};class f{constructor(e){this._db=null,this._cacheName=e}_upgradeDb(e){const t=e.createObjectStore(o,{keyPath:"id"});t.createIndex("cacheName","cacheName",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(e){this._upgradeDb(e),this._cacheName&&x(this._cacheName)}async setTimestamp(e,t){e=d(e);const a={url:e,timestamp:t,cacheName:this._cacheName,id:this._getId(e)},i=(await this.getDb()).transaction(o,"readwrite",{durability:"relaxed"});await i.store.put(a),await i.done}async getTimestamp(e){const a=await(await this.getDb()).get(o,this._getId(e));return a==null?void 0:a.timestamp}async expireEntries(e,t){const a=await this.getDb();let s=await a.transaction(o).store.index("timestamp").openCursor(null,"prev");const i=[];let h=0;for(;s;){const n=s.value;n.cacheName===this._cacheName&&(e&&n.timestamp<e||t&&h>=t?i.push(s.value):h++),s=await s.continue()}const c=[];for(const n of i)await a.delete(o,n.id),c.push(n.url);return c}_getId(e){return this._cacheName+"|"+d(e)}async getDb(){return this._db||(this._db=await g(w,1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}}class E{constructor(e,t={}){this._isRunning=!1,this._rerunRequested=!1,this._maxEntries=t.maxEntries,this._maxAgeSeconds=t.maxAgeSeconds,this._matchOptions=t.matchOptions,this._cacheName=e,this._timestampModel=new f(e)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;const e=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:0,t=await this._timestampModel.expireEntries(e,this._maxEntries),a=await self.caches.open(this._cacheName);for(const s of t)await a.delete(s,this._matchOptions);this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,m(this.expireEntries()))}async updateTimestamp(e){await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(this._maxAgeSeconds){const t=await this._timestampModel.getTimestamp(e),a=Date.now()-this._maxAgeSeconds*1e3;return t!==void 0?t<a:!0}else return!1}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}class T{constructor(e={}){this.cachedResponseWillBeUsed=async({event:t,request:a,cacheName:s,cachedResponse:i})=>{if(!i)return null;const h=this._isResponseDateFresh(i),c=this._getCacheExpiration(s);m(c.expireEntries());const n=c.updateTimestamp(a.url);if(t)try{t.waitUntil(n)}catch{}return h?i:null},this.cacheDidUpdate=async({cacheName:t,request:a})=>{const s=this._getCacheExpiration(t);await s.updateTimestamp(a.url),await s.expireEntries()},this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&u(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(e){if(e===p.getRuntimeName())throw new l("expire-custom-caches-only");let t=this._cacheExpirations.get(e);return t||(t=new E(e,this._config),this._cacheExpirations.set(e,t)),t}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;const t=this._getDateHeaderTimestamp(e);if(t===null)return!0;const a=Date.now();return t>=a-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;const t=e.headers.get("date"),s=new Date(t).getTime();return isNaN(s)?null:s}async deleteCacheAndMetadata(){for(const[e,t]of this._cacheExpirations)await self.caches.delete(e),await t.delete();this._cacheExpirations=new Map}}export{T as E};
